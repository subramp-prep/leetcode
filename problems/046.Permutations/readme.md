## 046. Permutations (Medium)

### **链接**：
题目：https://leetcode.com/problems/permutations/  
代码(github)：https://github.com/JianghanLi/LeetCode

### **题意**：
给一个无重复数的数组，要求给出所有数调换位置可能情况。

### **分析**：
因为此题要求给出所有可能情况，所以只能全部枚举。

1. 深度优先搜索：时间复杂度O(n!)，空间复杂度O(n!)。
	- 思路：permutate([1...n]) = [1]permutate([2...n]) + [2]permutate([1,3...n]) + ... + [n]permutate([1...n-1])
	- 步骤：
		- 递归起点：原数组，0为原集合遍历起点，输入迭代函数
		- 递归过程：
			- 从集合起点for循环，遍历输入的数组，交换集合起点和遍历到的数，输入迭代函数
		- 结束条件：集合起点到达集合尾端，放入输入的数组。
		
2. 迭代法-交换：时间复杂度O(n!)，空间复杂度O(n)。
	- 从结果只包含原数组开始，遍历结果中的数组：
		- 初始：[[1 2 3 4 5]]
		- 第一位和后面所有位分别交换：[[1 2 3 4 5] [2 1 3 4 5] [3 2 1 4 5] [4 2 3 1 5] [5 2 3 4 1]]
		- 第二位和后面所有位分别交换：...
	- 完成第i位数(i = 1...n-1)与后面数的交换，结果的长度都乘(n-i+1)，所以结果长度为n!

3. 迭代法-添加：时间复杂度O(n*n!)，空间复杂度O(n)。
	- 思路：遍历数组nums，当遍历到nums[i]时，结果中是nums[0]至nums[i-1]的全排列。
	- 步骤：
		0. 初始化，res中放入空集
		1. 第一个for循环：遍历nums，取nums[i]
		2. 第二个for循环：遍历res中存在的数组res[j]
		3. 第三个for循环：每个res[j]所有位置都分别插入nums[i]，再放入res
	
### **相关问题**：
[047. Permutations II](../047.Permutations_II)