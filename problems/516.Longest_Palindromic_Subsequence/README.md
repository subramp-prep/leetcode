## 516. Longest Palindromic Subsequence (Medium)

### **链接**：
题目：https://leetcode.com/problems/longest-palindromic-subsequence  
题解：https://github.com/JianghanLi/LeetCode

### **题意**
给一个字符串，求其最长的回文子字符串的长度（不要求连续）。


### **分析**  
1. 暴力搜索（Brute Force）+递归：时间复杂度O(2^n)，空间复杂度O(2^n)。
	- 思路：
		- 从字符串两端向中间缩进：
			- 若两端字符相等，则两个字符都属于这个回文子串，2 + 去掉两端字符之后的字符串，的回文子串长度
			- 若两端字符不等，减去左端或右端字符中的字符串的回文子串长度的更大值。
		- 结束条件：左右端相遇。
	- 此思路因为有相当多的重复计算，所以复杂度很高，但若引入一个表来记忆已进行过的计算，则可以将时间复杂度降至O(n^2)
	
2. 动态规划（DP）：时间复杂度O(n^2)，空间复杂度O(n^2)。
	- 思路和自暴力搜索相似，但从中间字符向两边遍历
	- dp[i][j]储存的是s[i..j]的最长回文子串长度（所以矩阵只用了右上三角形）：
		- 初始化：dp[k][k] = 1
		- 更新：
			- 顺序：右下至左上
			- 若s[i] == s[j]：dp[i][j] = dp[i + 1]dp[j - 1] + 2
			- 若s[i] != s[j]：dp[i][j] = max(dp[i + 1]dp[j], dp[i][j - 1]