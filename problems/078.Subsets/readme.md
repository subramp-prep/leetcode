## 78. Subsets (Medium)

### **链接**：

题目：https://leetcode.com/problems/subsets/  
代码(github)：https://github.com/JianghanLi/LeetCode

### **题意**：

给出一个其中数互不相同的集合，要求给出所有子集。

### **分析**：
因为此题要求给出所有的子集，所以只能通过各种暴力搜索方法全部枚举。

1. 深度优先搜索：时间复杂度O(2^n)，空间复杂度O(2^n)。
	- 思路：
		- 递归起点：空集为子集起点，0为原集合遍历起点，输入迭代函数
		- 递归过程：
			- 将子集放入结果
			- 从集合起点for循环遍历nums，在输入子集的基础上添加nums[i]，再输入迭代函数
		- 结束条件：集合起点到达集合尾端

2. 迭代法：时间复杂度O(2^n)，空间复杂度O(n)。
	- 从结果只包含一个空集开始，遍历原集合nums，将结果中存在的所有子集中，都加入nums[i]，添加到结果尾端：
		1. 初始：[[]]
		2. 向所有子集添加第一个数: [[], [1]]
		3. 向所有子集添加第二个数: [[], [1], [2], [1, 2]]
		4. 向所有子集添加第三个数: [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]
		5. ...
	- 每遍历一个数，结果的长度都会翻倍。最终达到2^n。
	
3. 二进制法：时间复杂度O(n*2^n)，空间复杂度O(n)。
	- 找出所有子集的过程实际也是找出所有集合中数的排列组合的可能性的过程：
		- 每个数只有两种可能：要么在子集中，要么不在 => 可以用二进制中的一位表示0或1
	- 从0到2^n的二进制数，每一个数都代表了一种可能性，根据此二进制数的特征，加入相应的子集即可。
	
### **相关问题**：
[90. Subsets II](../090.Subsets_II)