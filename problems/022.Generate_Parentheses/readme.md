## 022.Generate Parentheses (Medium)

### **链接**：
题目：https://leetcode.com/problems/generate-parentheses/
代码(github)：https://github.com/JianghanLi/LeetCode

### **题意**：
给出需要的括号对数，生成包含所有可能的成对的"("")"的字符串组

### **分析**：
在做这题之前，需要了解一个概念：[卡塔兰数](https://en.wikipedia.org/wiki/Catalan_number) Cat(n) = C(2n, n)/(n + 1)。  
这是最后结果中字符串的个数，对于计算算法的复杂度很重要。

1. 深度优先搜索（DFS） + 递归法：时间复杂度：O(n*Cat(n))，空间复杂度：O(n*n*Cat(n))
	- 对产生string的过程进行递归，每个递归结束时向结果中加入此string。
	- 生成string的规则：每次递归添加"("或")"，并确保
		1. 添加"("和")"各n个
		2. 在添加")"之前已有对应的"("添加
	- [复杂度的计算](https://stackoverflow.com/questions/37385964/time-complexity-for-combination-of-parentheses/37386711#37386711)：
		- 时间复杂度：最终的结果中有Cat(n)个字符串，每次递归都会向字符串中添1个字符，每个字符串都需要n次递归来构成，故O(n*Cat(n))
		- 空间复杂度：每次递归都会通过参数复制未完成的字符串，所以每个递归函数都会再占<=n个空间大小。
		
2. 动态规划（DP）：时间复杂度：O(n*Cat(n))，空间复杂度：O(n*n*Cat(n))
	- 建立一个大小为n的数组，一步一步储存括号对数为1..n的结果，第i步的可以在前1..i-1歩的基础上取得，原理大致如下 :
	```
	step_0 ""  
	step_1, "(s0)"  
	step_2, "(s0)s1" "(s1)s0"  
	step_3, "(s0)s2" "(s1)s1" "(s2)s0"  
	...
	```
	- 复杂度的计算：
		- 时间复杂度：在最终的代码中有4个for循环：
			1. 第一个for循环 i : 1 -> n
			2. 剩下3个for循环：进行的计算数最多是i = n 时，得到Cat(n)个字符串作为结果 => O(n*Cat(n))
		- 空间复杂度：n个表格，最长的表格的字符串个数是卡塔兰数，每个字符串有<=n个字符，所以复杂度O(n*n*Cat(n))。
		
关于两种算法的复杂度：看似思路2动态规划的空间复杂度要高于思路1深度优先搜索的，但其实两者是一样的。  
因为思路2在递归函数中，会把未构建完的字符串通过参数复制进去，由此算来，思路2中所有储存过的字符串，  
在思路1都复制过，并在递归结束前保留在递归函数中。